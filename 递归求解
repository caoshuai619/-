//递归求解，每当有一个人出圈时，出圈人的下一位就成了新的环的头部，相当于把数据向前移动m位。
//若已知f(n-1,m)--胜利者的下标，则n个人，就是往后移动了n位，考虑越界问题，超过的部分要接到头上，则模n

//所以递推关系式  f(n,m)=(f(n-1,m)+m-1)%n+1     m-1数组从1开始算起，但是下标是从0算的。

//   例如  原先的环                      0 1 2 3 4 5 6 7 8 9  10个数    设步长4
      3的位置被干掉                      0 1 2   4 5 6 7 8 9
      可以映射                     新环: 6 7 8   0 1 2 3 4 5         (4-4)%10 = 0
      新的环的位置=               第二轮：6 7 8   0 1 2   4 5
      (旧环位置-步长)%旧的数组     新环   2 3 4   5  6 7   0 1           一次类推
                                               .
                                  最后           0                   最后一轮 与第一轮的4对应 ，则最后4是存活的


//所以，根据上述关系可以得出：   旧环中对应的位置=(新环中的位置+步长)%旧的数组  我们可以递归得到，因为当环中只有一个人或者两个人时候，我们可以很容易得到
									   新环的数组下标就是0 ，然后根据递推得出原始环中的位置
                                                                            


int YuSeFU(int n,int m) {                       
	if (n <= 1 || m < 1) return -1;        
	if (n == 2) {
		if (n%m == 0) return 1;
		else return 2;
	}
	return (YuSeFU(n - 1, m)+m-1) % n + 1;    //注意，这里我们-1和+1是方便为了返回真实的位置，即从1开始的位置
}
